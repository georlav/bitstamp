// Just a simple tool that retrieves all available pairs from bitstamp and
// generates a fresh pair enums file (pair.go)
package main

import (
	"context"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"sort"
	"strings"

	"github.com/georlav/bitstamp"
)

type pair struct {
	Name    string
	URLName string
}

func main() {
	c := bitstamp.NewHTTPAPI()
	results, err := c.GetTradingPairsInfo(context.Background())
	if err != nil {
		log.Fatal("Failed to retrieve pairs")
	}

	var pairs []pair
	for i := range results {
		pairs = append(pairs, pair{
			Name:    strings.ReplaceAll(results[i].Name, "/", ""),
			URLName: results[i].URLSymbol,
		})
	}
	sort.Slice(pairs, func(i, j int) bool {
		return pairs[i].Name < pairs[j].Name
	})

	var pairIotas string
	var pairStrings string

	for i := range pairs {
		if i == 0 {
			pairIotas += pairs[i].Name + " Pair = iota\n"
			continue
		}

		pairIotas += pairs[i].Name + "\n"
		pairStrings += fmt.Sprintf(`%s: "%s",`+"\n", pairs[i].Name, pairs[i].URLName)

		if len(pairs)-1 == i {
			pairIotas += "NILNIL" + "\n"
			pairStrings += "NILNIL: " + `"nilnil",` + "\n"
		}
	}

	code := `// Code generated by generatepairs tool. DO NOT EDIT
	package bitstamp

	type Pair uint32

	const (
		%s
	)

	func (p Pair) String() string {
		return getPairs()[p]
	}

	func getPairs() map[Pair]string {
		return map[Pair]string{
			%s
		}
	}
`
	b, err := format.Source([]byte(fmt.Sprintf(code, pairIotas, pairStrings)))
	if err != nil {
		log.Fatalf("Failed to format generated code, %s", err)
	}

	if err := ioutil.WriteFile("pair.go", b, 0664); err != nil {
		log.Fatal("Failed to create pairs file")
	}
}
